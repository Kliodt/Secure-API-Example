# Информационная безопасность. Лаб. 1

Данное приложение реализует функциональность хранения массива пользователей и их 
любимых цитат

Пользователь может:
- Регистрироваться
- Входить в систему по никнейму и паролю

Зарегистрированный пользователь может:
- Получать никнеймы и любимые цитаты других пользователей
- Изменять свои никнейм и любимую цитату

## Описание эндпоинтов

- `auth/login` - осуществить вход пользователя в систему
  - Принимает в теле запроса: 
    - `username` - строка длинной от 4 до 32 символов
    - `password` - строка длинной от 8 до 64 символов
  - Аутентификация: -
  - Возвращает: 
    - `200 Ok`, данные о пользователе и токен в теле ответа, если пользователь существует и успешно вошел в систему
    - `404 Not Found`, если пользователя с таким именем не существует
    - `401 Unauthorized`, если пароль неверный


- `auth/register` - зарегистрировать нового пользователя
  - Принимает в теле запроса:
    - `username` - строка длинной от 4 до 32 символов, уникальное имя пользователя
    - `password` - строка длинной от 8 до 64 символов
  - Аутентификация: -
  - Возвращает:
    - `201 Created`, данные о пользователе и токен в теле ответа, если пользователь успешно добавлен
    - `409 Conflict`, если пользователь с таким именем уже зарегистрирован


- `api/data` - получить информацию о всех пользователях
  - Принимает в теле запроса: -
  - Аутентификация: токен формата `Bearer eyJhbGciOiJSUzIA...` в заголовке `Authorization`
  - Возвращает:
    - `200 Ok` и список с информацией о всех пользователях
    - `401 Unauthorized`, если токен не передан, невалиден или просрочен
 

- `auth/update_user` - обновить информацию о пользователе
  - Принимает в теле запроса: 
    - `id` пользователя (собственный) 
    - `username` - строка длинной от 4 до 32 символов
    - `favoriteQuote` - строка или null
  - Аутентификация: токен формата `Bearer eyJhbGciOiJSUzIA...` в заголовке `Authorization`
  - Возвращает:
    - `200 Ok` и обновленную информацию о пользователе
    - `401 Unauthorized`, если токен не передан, невалиден или просрочен
    - `403 Forbidden`, если переданный id не соответствует id полученному из токена
    - `404 Not Found`, если пользователь не найден
    - `409 Conflict`, если пользователь изменил имя, но с таким именем уже зарегистрирован другой пользователь



## Реализованные меры защиты

### От SQLi

Использование Spring Data JPA, который автоматически генерирует  
запросы к базе данных исходя из имени метода. 

Оно генерирует **параметризованные** запросы, 
то есть вместо параметров в них подставлены знаки `?`.
Параметры же запроса передаются отдельно (не используя конкатенацию). 
Это предотвращает исполнение пользовательского ввода как кода SQL.

```java
public interface UserRepository extends CrudRepository<User, Long> {
    User findUserByUsername(String username);
}
```

### От XSS

Использование кастомного JSON-сериализатора для всех возвращаемых строк.
В сериализаторе символы ` & < > " ' ` заменяются на их аналоги `&amp; &lt; &gt; &#34; &#39;`.

Таким образом, опасные (с точки зрения XSS) символы заменяются на их безопасные аналоги. 
Что помогает предотвратить возможную атаку.


```java
public class EscapeJsonSerializer extends JsonSerializer<String> {
    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
        gen.writeString(Encode.forHtml(value));
    }
}
```

```java
public class UserDTO {

    @JsonSerialize(using = EscapeJsonSerializer.class)
    private String favoriteQuote;

    // other fields and methods...
}
```

Пример работы данной меры защиты:

![alt text](assets/README/1759324835113_image.png)


### От Broken Authentication

- При регистрации/входе пользователя ему выдается токен. Токен содержит информацию 
  о пользователе - его уникальный id. Токен подписан секретным ключом, и имеет ограниченное 
  время жизни. Токен используется при запросах к API для 
  аутентификации пользователя (проверка подлинности токена и что он не истёк) и 
  идентификации пользователя (т.е получения его id). 

- для всех защищенных эндпоинтов (`/api/**`) настроен доступ только при условии, что в запросе 
  передан валидный непросроченный токен 
  (см. [SecurityConfig.java](src/main/java/ru/secureapiexample/security/SecurityConfig.java))

- Пароли хранятся в защищенном виде - закодированные алгоритмом bcrypt. 
  Минимальная длинна пароля - 8 символов, что дает дополнительную защиту


## Отчет spotbugs

![alt text](assets/README/1759331800088_image.png)

Документ: [spotbugs.html](assets/spotbugs.html)


## Отчет github dependabot

![alt text](assets/README/1759331977926_image.png)

Была найдена одна уязвимость. Но при проверке `./gradlew dependencies` 

```
./gradlew dependencies

...

spotbugs - configuration for the SpotBugs engine
\--- com.github.spotbugs:spotbugs:4.9.6

      ...
      
     +--- org.apache.bcel:bcel:6.10.0
     |    \--- org.apache.commons:commons-lang3:3.14.0 -> 3.17.0
     +--- com.github.stephenc.jcip:jcip-annotations:1.0-1
     +--- org.dom4j:dom4j:2.2.0
     +--- org.apache.commons:commons-lang3:3.18.0 -> 3.17.0
     +--- org.apache.commons:commons-text:1.14.0
     |    \--- org.apache.commons:commons-lang3:3.18.0 -> 3.17.0
     ...

```

оказалось что эту зависимость подтягивает только
плагин `com.github.spotbugs`, а эта значит уязвимость не 
страшна во время выполнения программы. 
Поэтому ничего с ней не делал.

## Последний успешный пайплайн

https://github.com/Kliodt/Secure-API-Example/actions


## Примеры запросов (Postman)

### Примеры корректной работы эндпоинтов

- `/auth/register_user`
  ![alt text](assets/README/1759324981448_image.png)

- `/auth/login`
  ![alt text](assets/README/1759325044814_image.png)

- `/api/update_user`
  ![alt text](assets/README/1759325102011_image.png)

- `/api/data`
  ![alt text](assets/README/1759325152366_image.png)

### Пример попытки логина по неправильному паролю

![alt text](assets/README/1759325236232_image.png)

### Пример попытки неавторизованного доступа к API

![alt text](assets/README/1759325413245_image.png)